library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity PacMan_Sound is
    Port (
        CLK_IN    : in  STD_LOGIC; 
        AUDIO_OUT : out STD_LOGIC   -- Salida de audio 
    );
end PacMan_Sound;

architecture Behavioral of PacMan_Sound is
 
    constant CLK_FREQ : integer := 100_000_000;
    constant FREQ_LOW  : integer := 900; --Frencuencias para las notas que del Pacman
    constant FREQ_HIGH : integer := 1046;
    constant HALF_PERIOD_LOW  : integer := CLK_FREQ / (2 * FREQ_LOW);
    constant HALF_PERIOD_HIGH : integer := CLK_FREQ / (2 * FREQ_HIGH);
    constant NOTE_DURATION_MS : integer := 130; --Duración de la nota
    constant NOTE_DURATION    : integer := (CLK_FREQ / 1000) * NOTE_DURATION_MS;

    type STATE_TYPE is (S_LOW, S_HIGH); --Máquina de estados para imitar el sonido
    signal state    : STATE_TYPE := S_LOW;
    signal counter  : integer := 0;  
    signal tone_cnt : integer := 0;  
    signal half_per : integer := HALF_PERIOD_LOW;
    signal audio_sig: STD_LOGIC := '0';

begin

    process(CLK_IN)
    begin
        if rising_edge(CLK_IN) then
            -- Controla el tiempo que se mantiene cada nota
            if counter < NOTE_DURATION then
                counter <= counter + 1;
            else
                counter <= 0;
                -- Nota baja y alta
                if state = S_LOW then
                    state    <= S_HIGH;
                    half_per <= HALF_PERIOD_HIGH;
                else
                    state    <= S_LOW;
                    half_per <= HALF_PERIOD_LOW;
                end if;
            end if;

            -- Genera la onda cuadrada
            if tone_cnt < half_per then
                tone_cnt <= tone_cnt + 1;
            else
                tone_cnt <= 0;
                audio_sig <= not audio_sig;
            end if;
        end if;
    end process;

    AUDIO_OUT <= audio_sig;

end Behavioral;
